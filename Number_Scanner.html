<!doctype html>
<html>
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
<title>Box Finder</title>
<meta name="theme-color" content="#0b1020" />
<style>
  :root{--bg:#0b1020;--muted:#a9b;--panel:#0f1430}
  *{box-sizing:border-box}
  body{margin:0;background:var(--bg);color:#eaf;font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif}
  header{padding:10px 14px;position:sticky;top:0;background:#0b1020e6;backdrop-filter:blur(4px);z-index:2}
  #wrap{display:grid;grid-template-columns:minmax(280px,1fr) 340px;gap:14px;padding:14px}
  #view{position:relative;width:100%;max-width:980px;margin:0 auto}
  #view::before{content:"";display:block;padding-top:56%} /* keep space until video is ready */
  video{
    position:absolute; inset:0; width:100%; height:100%;
    display:block; border-radius:10px; background:#000; object-fit:cover;
  }
  #overlay{
    position:absolute; inset:0; width:100%; height:100%;
    display:block; border-radius:10px; pointer-events:none;
    background:transparent !important; opacity:0; /* show when sized */
  }
  aside{font-size:14px}
  input,button,select{font:inherit}
  .muted{color:var(--muted)}
  #log{height:160px;overflow:auto;background:var(--panel);border:1px solid #27305f;padding:8px;border-radius:8px;font-family:ui-monospace,Menlo,Consolas,monospace;font-size:12px;white-space:pre-wrap}
  .pill{display:inline-block;padding:2px 8px;border:1px solid #3a4;border-radius:999px;margin-left:8px;font-size:12px}
  .row{display:flex;gap:8px;align-items:center;flex-wrap:wrap;margin-bottom:8px}
</style>
</head>
<body>
<header>
  <strong>Box Finder</strong>
  <span id="status" class="muted">loading…</span>
  <span class="pill">iOS optimized</span>
</header>

<div id="wrap">
  <div id="view">
    <video id="video" autoplay playsinline muted></video>
    <canvas id="overlay"></canvas>
  </div>

  <aside>
    <div class="row">
      <label>Target(s):</label>
      <input id="query" value="6539" size="22" placeholder="e.g., 6539, 6502, 6540">
    </div>
    <div class="row">
      <button id="snap">Recognize now</button>
      <label>Refresh:</label>
      <select id="rate">
        <option value="1500">Every 1.5s</option>
        <option value="1000" selected>Every 1s</option>
        <option value="500">Every 0.5s</option>
        <option value="0">Manual only</option>
      </select>
      <label><input type="checkbox" id="showAll" checked> show all OCR boxes</label>
      <label><input type="checkbox" id="beep" checked> beep on match</label>
      <button id="flip">Flip camera</button>
    </div>
    <div id="log" class="muted"></div>
    <p class="muted">Tips: good lighting • keep labels upright • move slowly.</p>
  </aside>
</div>

<!-- Tesseract v4 (stable on iOS Safari) -->
<script src="https://cdn.jsdelivr.net/npm/tesseract.js@4.1.1/dist/tesseract.min.js"></script>
<script>
/* -------------------- DOM / state -------------------- */
const video   = document.getElementById('video');
const overlay = document.getElementById('overlay');
const ctx     = overlay.getContext('2d');
const statusEl= document.getElementById('status');
const queryEl = document.getElementById('query');
const rateEl  = document.getElementById('rate');
const snapBtn = document.getElementById('snap');
const showAll = document.getElementById('showAll');
const beepChk = document.getElementById('beep');
const logEl   = document.getElementById('log');
const flipBtn = document.getElementById('flip');

let timer=null, busy=false, stream=null, currentFacing='environment';
let lastBeepAt=0;

/* -------------------- helpers -------------------- */
function log(m){ console.log(m); logEl.textContent=(m+"\n"+logEl.textContent).slice(0,9000); }

function sizeCanvas(){
  const w = video.videoWidth || overlay.clientWidth || 1280;
  const h = video.videoHeight|| overlay.clientHeight|| 720;
  overlay.width = w; overlay.height = h;
  overlay.style.opacity = '1';
}

/* Small embedded beep (440Hz blip) — no external files */
const beepAudio = new Audio('data:audio/wav;base64,UklGRkQAAABXQVZFZm10IBAAAAABAAEAESsAACJWAAACABYBWFlaAAAAAA=='); // ultra-short silent header; we'll synthesize with WebAudio for better effect
async function beep(){
  if (!beepChk.checked) return;
  const now = Date.now();
  if (now - lastBeepAt < 500) return; // throttle
  lastBeepAt = now;
  try{
    const ctxA = new (window.AudioContext||window.webkitAudioContext)();
    const o = ctxA.createOscillator(); const g = ctxA.createGain();
    o.type='sine'; o.frequency.value=880; // higher pitch
    g.gain.setValueAtTime(0.0001, ctxA.currentTime);
    g.gain.exponentialRampToValueAtTime(0.2, ctxA.currentTime+0.01);
    g.gain.exponentialRampToValueAtTime(0.0001, ctxA.currentTime+0.15);
    o.connect(g).connect(ctxA.destination); o.start(); o.stop(ctxA.currentTime+0.16);
  }catch(e){ /* ignore */ }
}

/* -------------------- camera -------------------- */
async function startCamera(facingMode='environment'){
  try{
    if (stream) stream.getTracks().forEach(t=>t.stop());
    video.muted = true;
    stream = await navigator.mediaDevices.getUserMedia({
      video: { facingMode, width: { ideal: 1280 }, height: { ideal: 720 } },
      audio: false
    });
    video.srcObject = stream;
    await video.play();
    sizeCanvas(); // in case events fired already
    video.addEventListener('loadedmetadata', sizeCanvas, { once:true });
    video.addEventListener('playing',        sizeCanvas, { once:true });
    window.addEventListener('resize', sizeCanvas);
    window.addEventListener('orientationchange', sizeCanvas);
    statusEl.textContent='ready';
    log('Camera ready.');
  }catch(e){
    statusEl.textContent='camera error';
    log('Camera error: '+e.name+' — '+e.message);
  }
}

flipBtn.onclick = () => {
  currentFacing = (currentFacing==='environment' ? 'user' : 'environment');
  startCamera(currentFacing);
};

/* -------------------- OCR + drawing -------------------- */
function parseTargets(){
  return (queryEl.value||'')
    .toUpperCase()
    .split(/[,\s]+/)
    .map(s=>s.trim())
    .filter(Boolean);
}

function getBoxes(data){
  const MIN_CONF = 70;
  if (Array.isArray(data.words) && data.words.length)
    return data.words
      .filter(w => (w.confidence||0) >= MIN_CONF)
      .map(w => ({ text:w.text, bbox:w.bbox }));
  if (Array.isArray(data.lines) && data.lines.length)
    return data.lines.map(w => ({ text:w.text, bbox:w.bbox }));
  return [];
}

function drawBoxes(data, scaleUsed){
  const targets = parseTargets();
  ctx.clearRect(0,0,overlay.width,overlay.height);
  const s = scaleUsed ? (1/scaleUsed) : 1;
  let hits = 0;

  const boxes = getBoxes(data).slice(0, 250); // safety cap

  if (showAll.checked){
    ctx.lineWidth=2; ctx.strokeStyle='rgba(200,200,220,0.5)';
    for(const w of boxes){ const b=w.bbox; ctx.strokeRect(b.x0*s,b.y0*s,(b.x1-b.x0)*s,(b.y1-b.y0)*s); }
  }
  if (targets.length){
    ctx.lineWidth=4; ctx.strokeStyle='#4cff4c'; ctx.fillStyle='rgba(76,255,76,0.25)';
    for(const w of boxes){
      const t=(w.text||'').toUpperCase();
      if (targets.some(tt => t.includes(tt))){
        const b=w.bbox;
        ctx.fillRect(b.x0*s,b.y0*s,(b.x1-b.x0)*s,(b.y1-b.y0)*s);
        ctx.strokeRect(b.x0*s,b.y0*s,(b.x1-b.x0)*s,(b.y1-b.y0)*s);
        hits++;
      }
    }
  }
  if (hits) beep();

  ctx.fillStyle='#eaf'; ctx.font='18px system-ui';
  const label = targets.length ? `Looking for ${targets.join(', ')} — matches: ${hits}` : 'Enter targets and press Recognize';
  ctx.fillText(label, 12, 24);
}

async function recognizeFrame(){
  if(busy || !video.videoWidth) return;
  busy = true;
  try{
    // downscale for speed but keep aspect
    const overlayW = overlay.width || 1280, overlayH = overlay.height || 720;
    const scale = 0.9;
    const w = Math.max(320, Math.floor(overlayW * scale));
    const h = Math.max(240, Math.floor(overlayH * scale));

    const tmp=document.createElement('canvas'); tmp.width=w; tmp.height=h;
    const tctx=tmp.getContext('2d',{willReadFrequently:true});
    tctx.drawImage(video,0,0,w,h);

    // grayscale + slight contrast bump
    const img=tctx.getImageData(0,0,w,h), d=img.data;
    for(let i=0;i<d.length;i+=4){
      const g=(d[i]*.3+d[i+1]*.59+d[i+2]*.11)|0;
      const c=Math.min(255,Math.max(0,(g-120)*1.12+120));
      d[i]=d[i+1]=d[i+2]=c;
    }
    tctx.putImageData(img,0,0);

    statusEl.textContent='recognizing…';
    const result = await Tesseract.recognize(tmp, 'eng', {
      logger: m => statusEl.textContent = m.status + (m.progress?` ${(m.progress*100|0)}%`:''),
      tessedit_char_whitelist: '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ-',
      tessedit_pageseg_mode: '6'
    });

    const text = (result.data.text||'').replace(/\s+/g,' ').trim();
    if (text) log('OCR: ' + text.slice(0,160));
    const scaleUsed = w / overlayW; // map OCR coords back to overlay
    drawBoxes(result.data, scaleUsed);
    statusEl.textContent='ready';
  }catch(e){
    statusEl.textContent='recognize error';
    log('recognize error: '+e.message);
  }finally{
    busy=false;
  }
}

/* -------------------- UI wiring -------------------- */
function scheduleLoop(){
  if (timer) clearInterval(timer);
  const ms = +rateEl.value;
  if (ms > 0) timer = setInterval(()=>recognizeFrame(), ms);
}
snapBtn.onclick = recognizeFrame;
rateEl.onchange  = scheduleLoop;
// re-run quickly when user changes targets
let qTimer=null;
queryEl.addEventListener('input', () => {
  clearTimeout(qTimer);
  qTimer = setTimeout(() => recognizeFrame(), 250);
});

/* -------------------- boot -------------------- */
(async ()=>{
  await startCamera('environment');
  scheduleLoop();
})();
</script>
</body>
</html>
