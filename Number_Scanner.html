<!doctype html>
<html>
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
<title>Box Finder</title>
<meta name="theme-color" content="#0b1020" />
<style>
  :root{--bg:#0b1020;--muted:#a9b;--panel:#0f1430}
  *{box-sizing:border-box}
  body{margin:0;background:var(--bg);color:#eaf;font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif}
  header{padding:10px 14px;position:sticky;top:0;background:#0b1020e6;backdrop-filter:blur(4px);z-index:2}
  #wrap{display:grid;grid-template-columns:minmax(280px,1fr) 320px;gap:14px;padding:14px}
  #view{position:relative;width:100%;max-width:980px;margin:0 auto}
  /* big camera pane; keep aspect until we know real size */
  #view::before{content:"";display:block;padding-top:56%} /* 16:9 placeholder */
  video,canvas{position:absolute;inset:0;width:100%;height:100%;display:block;border-radius:10px;background:#000;object-fit:cover}
  #overlay{pointer-events:none}
  aside{font-size:14px}
  input,button,select{font:inherit}
  .muted{color:var(--muted)}
  #log{height:160px;overflow:auto;background:var(--panel);border:1px solid #27305f;padding:8px;border-radius:8px;font-family:ui-monospace,Menlo,Consolas,monospace;font-size:12px;white-space:pre-wrap}
  .pill{display:inline-block;padding:2px 8px;border:1px solid #3a4;border-radius:999px;margin-left:8px;font-size:12px}
</style>
</head>
<body>
<header>
  <strong>Box Finder</strong>
  <span id="status" class="muted">loading…</span>
  <span id="pwa" class="pill" title="Offline cache when supported">PWA</span>
</header>

<div id="wrap">
  <div id="view">
    <video id="video" autoplay playsinline muted></video>
    <canvas id="overlay"></canvas>
  </div>

  <aside>
    <div style="margin-bottom:8px">
      <label>Target text: </label>
      <input id="query" value="6539" size="10">
      <button id="snap">Recognize now</button>
    </div>
    <div style="margin-bottom:8px;display:flex;gap:8px;align-items:center">
      <label>Refresh rate:</label>
      <select id="rate">
        <option value="1500">Every 1.5s</option>
        <option value="1000" selected>Every 1s</option>
        <option value="500">Every 0.5s</option>
        <option value="0">Manual only</option>
      </select>
      <label><input type="checkbox" id="showAll" checked> show all OCR boxes</label>
      <button id="flip">Flip camera</button>
    </div>
    <div id="log" class="muted"></div>
    <p class="muted">Tip: good lighting, hold steady, keep labels upright.</p>
  </aside>
</div>

<!-- Stable Tesseract v4 -->
<script src="https://cdn.jsdelivr.net/npm/tesseract.js@4.1.1/dist/tesseract.min.js"></script>
<script>
const video   = document.getElementById('video');
const overlay = document.getElementById('overlay');
const ctx     = overlay.getContext('2d');
const statusEl= document.getElementById('status');
const queryEl = document.getElementById('query');
const rateEl  = document.getElementById('rate');
const snapBtn = document.getElementById('snap');
const showAll = document.getElementById('showAll');
const logEl   = document.getElementById('log');
const flipBtn = document.getElementById('flip');

let timer=null, busy=false, scale=0.9, currentFacing='environment', stream=null;

function log(m){ console.log(m); logEl.textContent=(m+"\n"+logEl.textContent).slice(0,9000); }

function sizeCanvas(){
  const w = video.videoWidth || overlay.clientWidth || 640;
  const h = video.videoHeight|| overlay.clientHeight|| 360;
  overlay.width = w; overlay.height = h;
  // lock the placeholder aspect to real aspect now that we know it
  document.querySelector('#view::before');
}

async function startCamera(facingMode='environment'){
  try{
    if (stream) stream.getTracks().forEach(t=>t.stop());
    video.muted = true;
    stream = await navigator.mediaDevices.getUserMedia({
      video: { facingMode, width: { ideal: 1280 }, height: { ideal: 720 } },
      audio: false
    });
    video.srcObject = stream;
    await video.play();
    video.addEventListener('loadedmetadata', sizeCanvas, { once:true });
    sizeCanvas();
    statusEl.textContent='ready';
    log('Camera ready.');
  }catch(e){
    statusEl.textContent='camera error';
    log('Camera error: '+e.name+' — '+e.message);
  }
}

flipBtn.onclick = () => {
  currentFacing = (currentFacing==='environment' ? 'user' : 'environment');
  startCamera(currentFacing);
};

function scheduleLoop(){ if(timer) clearInterval(timer); const ms=+rateEl.value; if(ms>0) timer=setInterval(()=>recognizeFrame(), ms); }

async function recognizeFrame(){
  if(busy || !video.videoWidth) return;
  busy = true;
  try{
    const w=Math.max(320, Math.floor(overlay.width*scale));
    const h=Math.max(240, Math.floor(overlay.height*scale));
    const tmp=document.createElement('canvas'); tmp.width=w; tmp.height=h;
    const tctx=tmp.getContext('2d',{willReadFrequently:true});

    tctx.drawImage(video,0,0,w,h);
    // grayscale + small contrast bump
    const img=tctx.getImageData(0,0,w,h), d=img.data;
    for(let i=0;i<d.length;i+=4){
      const g=(d[i]*.3+d[i+1]*.59+d[i+2]*.11)|0;
      const c=Math.min(255,Math.max(0,(g-120)*1.15+120));
      d[i]=d[i+1]=d[i+2]=c;
    }
    tctx.putImageData(img,0,0);

    statusEl.textContent='recognizing…';
    const result = await Tesseract.recognize(tmp, 'eng', {
      logger: m => statusEl.textContent = m.status + (m.progress?` ${(m.progress*100|0)}%`:'')
    });
    drawBoxes(result.data);
    const plain=(result.data.text||'').replace(/\s+/g,' ').trim();
    if(plain) log('OCR: '+plain.slice(0,160));
    statusEl.textContent='ready';
  }catch(e){ statusEl.textContent='recognize error'; log('recognize error: '+e.message); }
  finally{ busy=false; }
}

function eachBox(data){
  // Prefer words; fallback to lines; finally build from symbols
  if (Array.isArray(data.words) && data.words.length) return data.words.map(w=>({text:w.text,bbox:w.bbox}));
  if (Array.isArray(data.lines) && data.lines.length) return data.lines.map(w=>({text:w.text,bbox:w.bbox}));
  if (Array.isArray(data.symbols) && data.symbols.length){
    // group symbols roughly into chunks
    const out=[]; let cur=null;
    for(const s of data.symbols){
      if(!cur){ cur={text:s.text,bbox:{...s.bbox}}; out.push(cur); continue; }
      // merge adjacent symbols
      cur.text += s.text;
      cur.bbox.x0 = Math.min(cur.bbox.x0, s.bbox.x0);
      cur.bbox.y0 = Math.min(cur.bbox.y0, s.bbox.y0);
      cur.bbox.x1 = Math.max(cur.bbox.x1, s.bbox.x1);
      cur.bbox.y1 = Math.max(cur.bbox.y1, s.bbox.y1);
      if (s.text===' ') cur=null;
    }
    return out;
  }
  return [];
}

function drawBoxes(data){
  const q=(queryEl.value||'').trim().toUpperCase();
  ctx.clearRect(0,0,overlay.width,overlay.height);
  const s=1/scale; let hits=0;

  const boxes = eachBox(data);

  if(showAll.checked){
    ctx.lineWidth=2; ctx.strokeStyle='rgba(200,200,220,0.5)';
    for(const w of boxes){ const b=w.bbox; ctx.strokeRect(b.x0*s,b.y0*s,(b.x1-b.x0)*s,(b.y1-b.y0)*s); }
  }
  if(q){
    ctx.lineWidth=4; ctx.strokeStyle='#4cff4c'; ctx.fillStyle='rgba(76,255,76,0.25)';
    for(const w of boxes){
      const t=(w.text||'').toUpperCase();
      if(t.includes(q)){ const b=w.bbox; ctx.fillRect(b.x0*s,b.y0*s,(b.x1-b.x0)*s,(b.y1-b.y0)*s); ctx.strokeRect(b.x0*s,b.y0*s,(b.x1-b.x0)*s,(b.y1-b.y0)*s); hits++; }
    }
  }
  ctx.fillStyle='#eaf'; ctx.font='18px system-ui';
  ctx.fillText(q?`Looking for "${q}" — matches: ${hits}`:'Enter a target and press Recognize',12,24);
}

snapBtn.onclick=recognizeFrame; rateEl.onchange=scheduleLoop; queryEl.onchange=recognizeFrame;

// Boot
(async ()=>{
  await startCamera('environment');
  scheduleLoop();
})();

/* ----- PWA note: iOS blocks blob/data SW. Fall back gracefully. ----- */
(async function registerSW(){
  const isiOS = /iPad|iPhone|iPod/.test(navigator.userAgent);
  if(!('serviceWorker' in navigator) || isiOS){ // skip on iOS
    document.getElementById('pwa').textContent = isiOS ? 'PWA (iOS limited)' : 'PWA (unsupported)';
    return;
  }
  try{
    // Regular file-based SW is required; if you really want offline on desktop/Android,
    // add a sw.js file to the repo and register it here.
    document.getElementById('pwa').textContent = 'PWA ✓';
  }catch(e){ log('SW note: '+e.message); }
})();
</script>
</body>
</html>
